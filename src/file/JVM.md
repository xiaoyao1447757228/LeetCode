# JVM知识点
- [第1章 走近Java](#1)
- [第2章 Java内存区域与内存溢出异常](#2)
- [第3章 垃圾收集器与内存分配策略](#3)
- [第4章 虚拟机性能监控与故障处理工具](#4)
- [第6章 类文件结构](#6)
- [第7章 虚拟机类加载机制](#7)
- [第8章 虚拟机字节码执行引擎](#8)
- [第10章 早期（编译期）优化 TODO](#10)
- [第11章 晚期（运行期）优化 TODO](#11)
- [第13章 线程安全与锁优化](#13)
## 第1章 走近Java
### Java虚拟机
[资料1](https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8)
[资料2](https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA)
Java虚拟机，能够运行Java字节码的虚拟机，是Java程序的运行环境。JVM屏蔽了与具体操作系统平台相关的信息，使得程序只需生成Java字节码，就可以在多种平台上不加修改地运行。
![](https://cdn.nlark.com/yuque/0/2020/png/690683/1584666686100-4da5517d-961a-42ae-8599-4625232e73cc.png#align=left&display=inline&height=376&originHeight=376&originWidth=338&size=0&status=done&style=none&width=338)
JVM主要包括两个子系统和两个组件。两个子系统分别是类加载器子系统和执行引擎子系统；两个组件分别是运行时数据区域组件和本地接口组件。

- 类加载器子系统：根据给定的全限定名类名来装载class文件的内容到运行时数据区域中的方法区。
- 执行引擎子系统：执行classes中的指令。
- 运行时数据区域：JVM所管理的内存区域。
- 本地接口组件：与本地库交互，是其它编程语言交互的接口。当调用native方法的时候，就进入了一个全新的并且不再受虚拟机限制的世界，所以也很容易出现JVM无法控制的native heap OutOfMemory。
# 自动内存管理机制
## 第2章 Java内存区域与内存溢出异常
### 运行时数据区域
[资料1](http://www.importnew.com/21463.html)
[资料2](http://blog.csdn.net/suifeng3051/article/details/48292193)
Java虚拟机将执行Java程序的过程中把它所管理的内存区域划分五个数据区域。属于线程私有的数据区域为程序计数器、Java虚拟机栈和本地方法栈；属于线程共享的数据区域为Java堆和方法区。
#### 程序计数器器（Program Counter Register）
当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值则为空。
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
#### 虚拟机栈（Java Virtual Machine Stacks）
虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
栈内存从严格意义上讲指的是虚拟机栈中局部变量表。局部变量表存放了编译器可知的八种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence类型）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用1个。
虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
#### 本地方法栈（Native Method Stack）
本地方法栈同虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为Native方法服务。
本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常。
#### 堆（Java Heap）
堆是用来存放对象实例的内存区域，是垃圾收集器管理的主要区域。堆中的区域分为新生代和老年代，新生代又可划分为Eden区和两块Survivor区。
Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例对象的内存分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常。
#### 方法区
方法区用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在HotSpot虚拟机中又称为永久代。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常。
#### 运行时常量池
是方法区的一部分。Class文件中的常量池用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载完成后存放于方法区的运行时常量池。

- 常量池（Constant Pool）：常量池数据在编译期被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量。
- 字符串池/字符串常量池（String Pool/String Constant Pool）：是常量池中的一部分，存储编译期类中产生的字符串类型数据。
- 运行时常量池（Runtime Constant Pool）：方法区中的一部分，Class文件中的常量池信息在类加载完成后存放以此。

Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。
当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
### 对象的创建过程
检查 -> 分配 -> 初始化 -> 对象头 -> 构造器

1. 检查：首先检查new指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先执行类加载过程。
1. 分配：为新生对象分配内存，即在Java堆中划分出一块确定大小的内存。分配方式有指针碰撞和空闲列表。
1. 初始化：虚拟机将分配到的内存空间都初始化为零值，不包括对象头。这一步保证了对象的实例字段在Java代码中不赋初始值就可以使用。
1. 对象头：设置对象的对象头，例如对象是哪个类的实例、对象的哈希吗，对象的GC分代年龄等信息。
1. 构造器：执行对象的方法。
### 对象的内存布局
对象的内存布局分为三个区域，分别是对象头、实例数据和对齐填充。

- 对象头：包含两部分信息，一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标识、线程持有的锁等；另一部分为类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- 实例数据：对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。
- 对齐填充：起着占位符的作用。
### 对象的访问定位
目前主流的访问方式有使用句柄和直接指针两种。

- 使用句柄：在堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄则包含了对象的实例数据指针和类型数据指针。

- 直接指针：reference中存储的就是对象在堆中的地址，而在堆中的对象数据则包含类型数据的指针。

- 使用句柄优点：reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

- 直接指针优点：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

### 内存溢出
当JVM无法申请到足够的内存空间时，就会导致内存溢出，即OutOfMemoryError。

- 堆溢出
- 虚拟机栈和本地方法栈溢出
- 方法区溢出
## 第3章 垃圾收集器与内存分配策略
### 判断对象存活的算法
#### 引用计数器算法
给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
优点：实现简单，判断效率高。
缺点：很难解决对象之间相互循环引用的问题。
#### 可达性分析算法
以GC Roots对象作为起始点向下搜索，搜索所走过的路径称为引用链，当一个对象与GC Roots对象之间没有任何引用链相连时，则证明此对象是不可能再被使用的。
可作为GC Roots的对象包括下面几种：

1. 虚拟机栈中栈帧的局部变量表引用对象。
1. 本地方法栈中Native方法引用的对象。
1. 方法区中常量引用的对象。
1. 方法区中类静态属性引用的对象。
### 四种引用方式
强软弱虚

1. 强引用：即`Object obj = new Object();`这样的引用。如果一个对象被强引用，即使内存不足，抛出OutOfMemoryError使程序终止，GC也不会回收它。
1. 软引用：即SoftReference，当发生GC时，若内存足够，不会回收软引用，若内存不足，则会回收。如果回收完还是没有足够内存，则抛出OutOfMemoryError。
1. 弱引用：即WeakReference，当发生GC时，无论当前内存是否足够，都会回收掉弱引用所关联的对象。
1. 虚引用：即PhantomReference，无法通过虚引用获得对象实例，只能和引用队列绑定使用达到通知的效果。当GC回收掉虚引用所关联的对象时，就会把这个虚引用加入到与之绑定的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被回收。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收前的资源释放工作。
### finalize()方法
如果对象覆盖了finalize()方法，则会在被回收之前执行该对象的finalize()方法。因为finalize()方法运行代价高，不确定性大，无法保证各个对象的调用顺序，因此要避免使用该方法。
若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。
### 方法区的回收
主要回收两部分内容：废弃常量和无用的类。

- 废弃常量：没有任何地方引用的常量，内存回收时这个常量就会被清理出常量池。
- 无用的类：该类所有的实例都已经被回收；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，并且无法在任何地方通过反射访问该类的方法。
### 垃圾收集算法
#### 标记-清除算法
算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记即为判断对象是否存活。
缺点：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量的内存碎片。
#### 复制算法
将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当某一块的内存用完了，就将仍存活的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
缺点：将内存缩小为了原来的一半，并且在对象存活率较高时需进行较多的复制操作，使效率降低。
改进：实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
当另一个Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。
#### 标记-整理算法
算法分为标记和整理两个阶段：首先标记出所有需要回收的对象，之后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。因为老年代中对象存活率高、没有额外空间进行分配担保，所以用作老年代的收集算法。
#### 分代收集算法
根据内存中各个年代的特点采用最适当的收集算法。一般是新生代使用复制算法，老年代使用“标记-清理”或“标记-整理”算法。
### OopMap、安全点和安全区域
[资料1](http://blog.csdn.net/woaigaolaoshi/article/details/51439227)
可以把OopMap简单理解成是调试信息。在源代码中每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。OopMap就是一个附加的信息，告诉你栈上哪个位置在编译前是什么类型，这个信息是在JIT编译时跟机器码一起产生的，因为只有编译器知道源代码跟产生的代码的对应关系。每个方法可能会有若干个OopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码拥有一个OopMap，作用域自然也仅限于这一段代码。
每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令时，栈和寄存器中哪些位置是引用。这样GC在扫描栈的时候只要查询这些OopMap就知道哪里是引用了。这些特定的位置主要在：

- 循环的末尾
- 方法返回前
- 调用方法的call指令后
- 可能抛出异常的位置

这种位置被称为“安全点”（safepoint），HotSpot中GC不是在任意位置都可以进入，而只能在safepoint处进入。
### 垃圾收集器
收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
#### Serial收集器
是一个单线程的，针对新生代，采用复制算法的收集器。在JDK1.3.1之前是虚拟机新生代收集的唯一选择，目前仍是虚拟机运行在Client模式下的默认新生代收集器。
单线程的意义不仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
优点：简单而高效（与其他收集器的单线程比）。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得较高的收集效率。
#### ParNew收集器
是一个多线程的，针对新生代，采用复制算法的收集器。ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为和Serial收集器一样。
并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上。
#### Parallel Scavenge收集器
是一个多线程的，针对新生代，采用复制算法的收集器。主要目标是达到一个可控制的吞吐量。
吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即`吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)`
#### Serial Old收集器
是一个单线程的，针对老年代，采用标记-整理算法的收集器。是Serial收集器的老年代版本，主要意义也是在于给Client模式下的虚拟机使用。
#### Parallel Old收集器
是一个多线程的，针对老年代，采用标记-整理算法的收集器。是Parallel Scavenge收集器的老年代版本。
Parallel Scavenge收集器可以和Parallel Old收集器组成吞吐量优先组合。
#### CMS收集器
是一个针对老年代，采用标记-清除算法，以获取最短回收停顿时间为目标的收集器。
运作步骤：初始标记、并发标记、重新标记和并发清除。
优点：并发收集，低停顿。
缺点：对CPU资源非常敏感，无法处理浮动垃圾，标记-清除算法会产生大量内存碎片。
#### G1收集器
是一款面向服务器端应用的垃圾收集器，未来目标是替换CMS收集器。
特点：

1. 并行与并发：利用多个CPU缩短Stop-The-World停顿的时间。
1. 分代收集：不需要与其他收集器配合就能独立管理整个GC堆。
1. 空间整合：从整体看是基于“标记-整理”算法，从局部看是基于复制算法。不会产生空间碎片。
1. 可预测的停顿

运作步骤：初始标记、并发标记、最终标记和筛选回收。
### 内存分配与回收策略

- 对象优先分配在Eden区：当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
- 大对象直接进入老年代：所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Survivor之间发生大量的内存复制。
- 长期存活的对象将进入老年代：如果对象在Eden区出生并且经历过一次Minor GC后仍然存活，并且能够被Survivor容纳，将被移动到Survivor空间中，并且把对象年龄设置成为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中。
- 动态对象年龄判定：如果在Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须等到MaxTenuringThreshold中要求的年龄。
- 空间分配担保：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。
### Minor GC、Major GC和Full GC
[资料1](http://www.importnew.com/15820.html)
新生代GC（Minor GC）：指发生在新生代的内存回收行为，因为Java对象大多都具备朝生夕灭的特性，所有Minor GC非常频繁，一般回收速度也比较快。
老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。
## 第4章 虚拟机性能监控与故障处理工具
### JDK命令行工具

- jps（虚拟机进程状况工具）：列出正在运行的虚拟机进程，并显示虚拟机执行主类名称，以及这些进程的本地虚拟机唯一ID。
- jstat（虚拟机统计信息监视工具）：用于监视虚拟机各种运行状态信息的命令行工具，例如显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
- jinfo（Java配置信息工具）：用于实时地查看和调整虚拟机各项参数。
- jmap（Java内存映像工具）：用于生成堆转储快照（一般称为heapdump或dump文件）。
- jhat（虚拟机堆转储快照分析工具）：与jmap搭配使用，来分析jmap生成的堆转储快照。
- jstack（Java堆栈跟踪工具）：用于生成虚拟机当前时刻的线程快照（一般称为threaddump或javacore文件）。
### JDK可视化工具

- JConsole（Java监视与管理控制台）：是一种基于JMX的可视化监视、管理工具。
- VisualVM（多合一故障处理工具）：是目前为止随JDK发布的功能最强大的运行监视和故障处理工具。
# 虚拟机执行子系统
## 第6章 类文件结构
### Class类文件的结构
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。
Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。表是由多个无符号数或者其他表作为数据项构成的数据，整个Class文件本质上就是一张表。

- 魔术
- 版本号
- 常量池：主要存放两大类常量，字面量和符号引用。
- 访问标志
- 类索引、父类索引和接口索引集合：Class文件由这三项数据来确定这个类的继承关系
- 字段表集合
- 方法表集合
- 属性表集合
#### 魔数与版本号
魔数：每个Class文件的头4个字节称为魔数，且为固定值0xCAFEBABE，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。
版本号：紧接着魔数的4个字节存储的是Class文件的版本号，第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45.0开始的。高版本的JDK能向下兼容以前版本的Class文件，但不能运行之后版本的Class文件。
#### 常量池
常量池可以理解为Class文件中的资源仓库。常量池的入口为一项u2类型的数据，代表常量池容量计数值，从1开始计数。
常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包含三部分内容：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
#### 访问标志
在常量池结束之后，紧接着的两个字节代表访问标志，用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定位public类；是否定义为abstract类型等。
#### 类索引、父类索引与接口索引集合
类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据集合，Class文件中由这三项数据来确定这个类的继承关系。
#### 字段表集合、方法表集合、属性表集合
字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表结构包含访问标志、名称索引、描述符索引、属性表集合。
方法表和字段表类同，描述接口或者类中声明的方法。
在Class文件、字段表、方法表都可以携带自己的属性表集合以用于描述某些场景专有的信息。比如Code属性描述方法表中Java代码编译成的字节码指令。
## 第7章 虚拟机类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
### 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。
加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这个是为了支持Java语言运行时绑定（也成为动态绑定或晚期绑定）。
虚拟机规范规定有且只有5种情况必须立即对类进行初始化，这5中场景中的行为称为对一个类进行主动一引用。

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
1. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
1. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
1. 当虚拟机启动时候，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
1. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
### 类加载的过程
#### 加载

1. 通过一个类的全限定名类获取定义此类的二进制字节流。
1. 将这字节流所代表的静态存储结构转化为方法区运行时数据结构。
1. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
#### 验证
验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
验证阶段包含4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
1. 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
1. 字节码验证：主要目的是通过数据流和控制流分析，确定程序的语义是合法的、符合逻辑的。
1. 符号引用验证：第四阶段的校验发生在虚拟机将符号引用转化为可直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符合引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。
#### 准备
准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量都在方法区中进行分配。这个时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
#### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- 直接引用：可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
#### 初始化
类的初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才正真开始执行类中定义的Java程序代码。
初始化阶段是执行类构造器()方法的过程，()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
### 类加载器
类加载器将描述一个类的二进制字节流加载到内存中，并为其生成对应的java.lang.Class对象。
从Java开发人员角度来看，类加载可以划分为三种：

- 启动类加载器（Bootstrap ClassLoader）：由C++语言实现，是虚拟机自身的一部分。负责将存放在<JAVA+HOME>\lib目录中的，或者被-Xbootclasspath参数所制定的路径中的，并且是JVM识别的（仅按照文件名识别，如rt.jar，如果名字不符合，即使放在lib目录中也不会被加载）：加载到虚拟机内存中，启动类加载器无法被JAVA程序直接引用。
- 扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）：由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般称它为系统类加载器。负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
#### 双亲委派模型
通过组合关系来实现的一种加载器层次模型，除了顶层的启动类加载器外，其余的类加载器都有自己的父类加载器。
实现原理：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
保证了某个范围的类一定是被某个类加载器所加载的，因此在程序中同一个类不会被不同的类加载器加载。从安全层面上考量，杜绝通过使用和JRE相同的类名冒充现有JRE的类达到替换的攻击方式。
## 第8章 虚拟机字节码执行引擎
### 运行时栈帧结构
栈帧：是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机栈中的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。
对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。

- 局部变量表：是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，以变量槽（Variable Slot）为最小单位。
- 操作数栈：又称为操作栈，是一个后进先出栈。在方法执行时，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。
- 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
- 方法返回地址：方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法退出的过程实际上就等于把当前栈帧出栈，可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整程序计数器的值以指向方法调用指令后面的一条指令等。
- 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如调试相关信息。
### 方法调用
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不设计方法内部的具体运行过程。
#### 解析
将方法的符号引用转化为直接引用。
静态解析：方法在程序执行前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。主要有静态方法、实例构造器方法、私有方法、父类方法和final方法。
动态解析：在类运行期间才能确定某些目标方法的直接引用。
#### 分派
分派是指虚拟机确定执行哪个的过程。
##### 静态分派和动态分派
_content_copy_
```
public class StaticDispatch {
    static abstract class Human {
    }
    static class Man extends Human {
    }
    static class Woman extends Human {
    }
    public void sayHello(Human human) {
        System.out.print("Hello, human.");
    }
    public void sayHello(Man man) {
        System.out.print("Hello, man.");
    }
    public void sayHello(Woman woman) {
        System.out.print("Hello, woman.");
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch dispatch = new StaticDispatch();
        dispatch.sayHello(man);
        dispatch.sayHello(woman);
    }
}
运行结果：
Hello, human.
Hello, human.
```
上面代码中的“Human”成为变量的静态类型或外观类型，后面的“Man”成为变量的实际类型。区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。
虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知的。
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用是方法重载。
在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
invokevirtual指令的运行时解析过程大致分为以下四个步骤：

1. 查找操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
1. 如果在类型C中找到与常量中的描述符和简单名称都符号的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。
1. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
1. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。
##### 单分派和多分派
方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派和多分派两种。Java语言中，静态分派属于多分派类型，动态分派属于单分派类型。
#### 虚方法表
由于动态分派是非常频繁的动作，所以虚拟机为了优化效率会为类在方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口地址。
### 基于栈的字节码解释执行引擎
#### 基于栈的指令集与基于寄存器的指令集
栈架构主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。
栈架构的主要缺点是执行速度相对来说会稍慢一些。
# 程序编译与代码优化
## 第10章 早期（编译期）优化
### Javac的源码与调试
编译过程大致可以分为3个过程，分别是：

- 解析与填充符号表过程
- 插入式注解处理器的注解处理过程
- 分析与字节码生成过程
### 语法糖
#### 泛型与类型擦除
泛型是JDK1.5的一项新特性，它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。
Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也成为裸类型）了，并且在相应的地方插入了强制转换类型代码。因此，对于运行期的Java语言来说，ArrayList与ArrayList就是同一个类。
#### 自动装箱、拆箱与foreach循环
自动拆箱、装箱在编译之后被转化成了对应的包装和还原方法，如Integer.valueOf()和Integer.intValue()方法。
自动装箱的陷阱：整型包装类、Character内部都实现了一个Cache对象，整型包装类缓存了-128到127之间的数值，Character类缓存了0到128之间的字符值。
foreach循环则把代码还原成了迭代器的实现。
可变参数在调用的时候变成了一个数组类型的参数。
#### 条件编译
Java语言中条件编译的实现，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉。
## 第11章 晚期（运行期）优化
### 解释器与编译器
### 编译过程
### 编译优化技术

- 公共子表达式消除
- 数组边界检查消除
- 方法内联
- 逃逸分析
# 高效并发
## 第12章 Java内存模型与线程
由于计算机的存储设备与处理器的运算速度差距几个数量级，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲。
### Java内存模型
Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须放在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。
**图**
8种原子操作：

- lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load操作使用。
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据类型的read、load、store和write这4个操作的原子性，这就是所谓的long和double的非原子性协定。但在实际中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待。
### volatile
[资料1](http://www.importnew.com/24082.html)
关键字volatile是Java虚拟机提供的最轻量级的同步机制。
当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的；第二是禁止指令重排优化。
volatile并不能确保原子性。
volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些。
### 原子性、可见性与有序性
[资料1](http://www.importnew.com/24082.html)
原子性：一个操作或者多个操作要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作。
可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。在Java中使用volatile关键字来保证可见性，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。除了volatile之外，synchronized和final也能实现可见性。
有序性：即程序执行的顺序按照代码的先后顺序执行。在Java中，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
### happens-before原则
先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能够被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了信息、调用了方法等。
默认的先行发生的八个规则：

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
- 对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，可以得出操作A先行发生于操作C的结论。

时间先后顺序与先行发生原则之间没有太大关系，所以衡量并发安全问题的时候以先行发生原则为准。
### 线程
#### 线程的实现
实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。
Java线程在JDK1.2之前，是基于成为“绿色线程”的用户线程实现的，而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。
#### 线程的调度
线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别为协同线程调度和抢占式线程调度。
#### 线程的状态
Java语言定义了5种线程状态，在任意一个时间点，一个线程有且只有一种状态，状态如下：

- 新建（New）：创建后尚未启动的线程。
- 运行（Runable）：处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
- 等待：分为无限期等待（Waiting）和限期等待（Timed Waiting），处于无限期等待的线程不会被分配CPU执行时间，它们需要被其他线程显式地唤醒。处于限期等待的线程也不会被分配CPU执行时间，但可以在一定时间之后由系统自动唤醒。
- 阻塞（Blocked）：与等待的区别是，阻塞状态在等待获取到一个排他锁，这个时间在另外一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。
## 第13章 线程安全与锁优化
线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
#### Java中的线程安全
Java语言中线程安全的具体体现分为5个程度：

1. 不可变：不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。
1. 绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。
1. 相对线程安全：即通常意义上所讲的线程安全，保证对这个对象单独的操作是线程安全的，在调用的时候不需要额外的保障措施。如Vector、Hashtable、Collections的synchronizedCollection()方法包装的集合等。
1. 线程兼容：指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。例如ArrayList、HashMap等。
1. 线程对立：指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。
#### 线程安全的实现方法

- 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方法。互斥是方法，同步是目的。
- 非阻塞同步：基于冲突检测的乐观并发策略。
- 无同步方案：不涉及共享数据的方法本身即为线程安全的，所以不需要同步。
##### 互斥同步
在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。
Java中的线程是映射到操作系统的原生线程之上，如果要阻塞或唤醒一个线程，都需要操作系统来完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块，状态转换消耗的时间有可能比用户代码执行的时间还要长。
ReentrantLock相比synchronized的高级功能：

- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，而非公平锁则不保证这一点。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的。
- 锁绑定多个调点是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个的条件关联的时候，就不得不额外地添加一个锁。
##### 非阻塞同步
基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作成功；否则产生冲突，那就再采取其他的补偿措施，如不断重试，直到成功。
CAS指令需要3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。
CAS存在漏洞，如果一个变量V初次读取的时候是A值，期间有可能被修改为B值后再次被修改成为A值，那么在准备赋值的时候检查到它仍然是A值，CAS操作会误认为它从来没有被修改过。又称为CAS操作的“ABA”问题。
### 锁优化
为了在线程之间更高效地共享数据，以及解决竞争问题。
#### 自旋锁与自适应自旋
自旋锁指让线程执行一个忙循环（自旋）进入等待状态。自旋等待并不能代替阻塞，首先对处理器数量有要求，其次自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。
#### 锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。
#### 锁粗化
如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体重的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。例如连续的append()方法。
#### 轻量级锁
在无竞争的情况下使用CAS操作去消除同步使用的互斥量。
#### 偏向锁
目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。
